import telebot, os, random, vt

Token = '<tu token>'
vt_api_key = '<tu api_key>'
chat_id = '<tu chat_id>'


bot = telebot.TeleBot(Token)

# -------Bienvenida
print('bienve')

# Manejar el evento de nuevos miembros en un grupo
@bot.message_handler(func=lambda message: True, content_types=['new_chat_members'])
def welcome_message(message):
    welcome_messages = [
        f'¡Bienvenid@ {message.from_user.first_name} a este grupo de hacking ético! Presentate, Hackea y pasalo genial.',
        f'¡Hola {message.from_user.first_name}! Bienvenid@ a este grupo. Estas Hack?',
        f'¡Saludos {message.from_user.first_name}! Bienvenid@ a ésta comunidad de Cyber. Si tienes alguna pregunta ética, no dudes en hacerla.',
        f'{message.from_user.first_name}, sé bienvenid@ al grupo más hack, a disfrutar!']
    random_welcome = random.choice(welcome_messages)
    bot.reply_to(message, random_welcome)


# -------Comandos
print('coman')

@bot.message_handler(commands=['pentest'])  # --Llamada a bot
def init(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, si utilizas /help, podras ver los comandos que tengo disponibles.'.format(user_name))
    print('pingu')

@bot.message_handler(commands=['nmap'])  # --Listado de comandos nmap
def nmap(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, los comandos de nmap son los siguientes: \n \n -->Descubrir sistemas: \n -PS n tcp syn ping \n -PA n ping TCP ACK \n -PU n ping UDP \n -PM Netmask Req \n -PP Timestamp Req \n -PE Echo Req \n -sL análisis de listado \n -PO ping por protocolo \n -PN No hacer ping \n -n no hacer DNS \n -R Resolver DNS en todos los sistemas objetivo \n –traceroute: trazar ruta al sistema (para topologías de red) \n -sP realizar ping, igual que con –PP –PM –PS443 –PA80 \n \n -->Técnicas de análisis de puertos: \n -sS análisis utilizando TCP SYN \n -sT análisis utilizando TCP CONNECT \n -sU análisis utilizando UDP \n -sY análisis utilizando SCTP INIT \n -sZ utilizando COOKIE ECHO de SCTP \n -sO protocolo IP \n -sW ventana TCP -sN \n –sF -sX NULL, FIN, XMAS \n –sA TCP ACK \n \n -->Puertos a analizar y orden de análisis: \n -p n-mrango \n -p– todos los puertos \n -p n,m,z especificados \n -p U:n-m,z T:n,m U para UDP, T para TCP \n  -F rápido, los 100 comunes \n –top-ports n analizar los puertos más utilizados \n -r no aleatorio \n \n -->Duración y ejecución: \n -T0 paranoico \n -T1 sigiloso \n -T2 sofisticado \n -T3 normal \n -T4 agresivo \n -T5 locura \n –min-hostgroup \n –max-hostgroup \n –min-rate \n –max-rate \n –min-parallelism \n –max-parallelism \n –min-rtt-timeout \n –max-rtt-timeout \n –initial-rtt-timeout \n –max-retries \n –host-timeout –scan-delay \n \n -->Detección de servicios y versiones: \n -sV: detección de la versión de servicios \n –all-ports no excluir puertos \n –version-all probar cada exploración \n –version-trace rastrear la actividad del análisis de versión-O activar detección del S. Operativo \n –fuzzy adivinar detección del SO \n –max-os-tries establecer número máximo de intentos contra el sistema objetivo \n \n -->Evasión de Firewalls/IDS: \n -f fragmentar paquetes \n -D d1,d2 encubrir análisis con señuelos \n -S ip falsear dirección origen \n –g source falsear puerto origen \n –randomize-hosts orden \n –spoof-mac <mac> cambiar MAC de origen \n \n -->Parámetros de nivel de detalle y depuración: \n -v Incrementar el nivel de detalle \n –reason motivos por sistema y puerto \n -d (1-9) establecer nivel de depuración \n –packet-trace ruta de paquetes \n \n -->Otras opciones: \n –resume file continuar análisis abortado (tomando formatos de salida con -oN o -oG) \n -6 activar análisis IPV6 \n -A agresivo, igual que con -O -sV -sC –traceroute \n \n -->Opciones interactivas: \n v/V aumentar/disminuir nivel de detalle del análisis \n d/D aumentar/disminuir nivel de depuración \n p/P activar/desactivar traza de paquetes \n \n -->Scripts: \n -sC realizar análisis con los scripts por defecto \n –script file ejecutar script (o todos) \n –script-args n=v proporcionar argumentos \n –script-trace mostrar comunicación entrante y saliente \n \n -->Formatos de salida: \n -oN guardar en formato normal \n -oX guardar en formato XML \n -oG guardar en formato para posteriormente usar Grep(una linea) \n -oA guardar en todos los formatos anteriores'.format(user_name))
    print('nmap')

@bot.message_handler(commands=['reverse'])   #--Reverse-Shell info
def reverse(message):
    print('reverse')
    try:
        # Construye la ruta del archivo .pdf independiente de la plataforma
        pdf_file_path = os.path.join(os.getcwd(), 'Pentest', 'Reverse_Shell.pdf')

        # Envía el mensaje de texto como respuesta al comando
        user_name = message.from_user.first_name
        bot.reply_to(message, 'Hola {}, mis sugerencias para realizar una reverse shell las tienes en el siguiente enlace de GitHub o sino, puedes revisar el archivo .pdf que te envío justo despues: \n'.format(user_name) + '\n' + 'https://github.com/0dayCTF/reverse-shell-generator')

        # Envía el archivo .pdf al chat
        with open(pdf_file_path, 'rb') as pdf_file:
            bot.send_document(message.chat.id, pdf_file)

    except Exception as e:
        bot.reply_to(message, "Ha ocurrido un error al enviar el archivo. Por favor, inténtalo más tarde.")
        print(f"Error: {e}")

# Manejador para el comando /puertos
@bot.message_handler(commands=['puertos'])
def puertos(message):
    print('puertos')
    try:
        # Construye la ruta del archivo .pdf independiente de la plataforma
        pdf_file_path = os.path.join(os.getcwd(), 'Pentest', 'Puertos_comunes.pdf')

        # Envía el mensaje de texto como respuesta al comando
        user_name = message.from_user.first_name
        bot.reply_to(message, 'Hola {}, los puertos utilizados más comunes, podrás verlos en el siguiente archivo .pdf: \n'.format(user_name))

        # Envía el archivo .pdf al chat
        with open(pdf_file_path, 'rb') as pdf_file:
            bot.send_document(message.chat.id, pdf_file)

    except Exception as e:
        bot.reply_to(message, "Ha ocurrido un error al enviar el archivo. Por favor, inténtalo más tarde.")
        print(f"Error: {e}")
    

@bot.message_handler(commands=['gobuster'])  
def gobuster(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a enumerar un ratito?? \n'.format(user_name) + gob)
    print('gobuster')
gob = '''
        Gobuster es una herramienta de fuerza bruta muy potente y con el objetivo de enumerar uris en sitios web, es decir, directorios y ficheros, subdominios dns y nombres de host virtuales en servidores web.
        
        Para la enumeración de subdominios dns utilizaremos la palabra clave dir, que como todo comando tiene su propia ayuda:
        
        Usage:
          gobuster dns [flags]
         
        Flags:
          -d, --domain string      The target domain
          -h, --help               help for dns
          -r, --resolver string    Use custom DNS server (format server.com or server.com:port)
          -c, --show-cname         Show CNAME records (cannot be used with '-i' option)
          -i, --show-ips           Show IP addresses
              --timeout duration   DNS resolver timeout (default 1s)
              --wildcard           Force continued operation when wildcard found
         
        Global Flags:
              --delay duration    Time each thread waits between requests (e.g. 1500ms)
              --no-error          Don't display errors
          -z, --no-progress       Don't display progress
          -o, --output string     Output file to write results to (defaults to stdout)
          -p, --pattern string    File containing replacement patterns
          -q, --quiet             Don't print the banner and other noise
          -t, --threads int       Number of concurrent threads (default 10)
          -v, --verbose           Verbose output (errors)
          -w, --wordlist string   Path to the wordlist
        
          Para la enumeración de virtual hosts utilizaremos la palabra clave vhost, que como todo comando tiene su propia ayuda:
        
        Usage:
          gobuster vhost [flags]
         
        Flags:
          -c, --cookies string        Cookies to use for the requests
          -r, --follow-redirect       Follow redirects
          -H, --headers stringArray   Specify HTTP headers, -H 'Header1: val1' -H 'Header2: val2'
          -h, --help                  help for vhost
          -m, --method string         Use the following HTTP method (default "GET")
          -k, --no-tls-validation     Skip TLS certificate verification
          -P, --password string       Password for Basic Auth
              --proxy string          Proxy to use for requests [http(s)://host:port]
              --random-agent          Use a random User-Agent string
              --timeout duration      HTTP Timeout (default 10s)
          -u, --url string            The target URL
          -a, --useragent string      Set the User-Agent string (default "gobuster/3.1.0")
          -U, --username string       Username for Basic Auth
         
        Global Flags:
              --delay duration    Time each thread waits between requests (e.g. 1500ms)
              --no-error          Don't display errors
          -z, --no-progress       Don't display progress
          -o, --output string     Output file to write results to (defaults to stdout)
          -p, --pattern string    File containing replacement patterns
          -q, --quiet             Don't print the banner and other noise
          -t, --threads int       Number of concurrent threads (default 10)
          -v, --verbose           Verbose output (errors)
          -w, --wordlist string   Path to the wordlist
        
        Para la enumeración de buckets S3 utilizaremos la palabra clave s3, que como todo comando tiene su propia ayuda:
         
        Usage:
          gobuster s3 [flags]
         
        Flags:
          -h, --help               help for s3
          -m, --maxfiles int       max files to list when listing buckets (only shown in verbose mode) (default 5)
              --proxy string       Proxy to use for requests [http(s)://host:port]
              --random-agent       Use a random User-Agent string
              --timeout duration   HTTP Timeout (default 10s)
          -a, --useragent string   Set the User-Agent string (default "gobuster/3.1.0")
         
        Global Flags:
              --delay duration    Time each thread waits between requests (e.g. 1500ms)
              --no-error          Don't display errors
          -z, --no-progress       Don't display progress
          -o, --output string     Output file to write results to (defaults to stdout)
          -p, --pattern string    File containing replacement patterns
          -q, --quiet             Don't print the banner and other noise
          -t, --threads int       Number of concurrent threads (default 10)
          -v, --verbose           Verbose output (errors)
          -w, --wordlist string   Path to the wordlist
'''

@bot.message_handler(commands=['sqlmap'])  
def sqlmap(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, su uso es --> \'python sqlmap.py [opciones]\' y las opciones te las dejo a continuación: \n'.format(user_name) + '''
                --url  url  (-u) con la variable vulnerable ejemplo elhacker.net/noticia.php?id=1
                -p (buscar otra variable vunlerable) elhacker.net/noticia.php?id=1&user
                --data si hay un formulario GET,POST los campos vulnerables
                --level=n cinco niveles según dificultad
                --dbs listar las bases de datos
                --dbms  motor de la base de datos (MySQL,SQL Server ,etc)
                 -D indicamos la base de datos a utilizar (-Database)
                 --tables mostrar las tablas disponibles 
                -t nombre de la tabla --columns
                --dump vuelca resultados, mostrar contenido de las tablas
                -C (Columnas) columnas a mostrar
                --wizard ejecuta un asistente
                 --threads=n número de procesos (por defecto 1)
                --delay=n segundos de espera entre peticiones http
                --current-db base de datos que está usando actualmente
                --current-user ver usuario que está ejecutando
                --is-dba –current-db ver si el usuario es el dba de la BD
                --privileges ver los privilegios del usuario (alter, create, drop, execute)
                --file-read path (ruta) leer ficheros
                --sql-shell obtener una sql en shell
                --os-shell obtener shell en el servidor (asp es la 1, aspx 2, jsp 3, php 4) (si se poseen los suficientes privilegios y un FPD (Full Path Disclosure)
                 --headers= cabeceras del navegador
                --random-agent cabeceras del navegador aleatorias
                --time-sec= Segundos para retrasar la respuesta de DBMS (por defecto 5)
                ---technique= : Se utiliza para seleccionar la técnica que se va a utilizar en la inyección ( B - E - U - S - T - Q.) Boolean-based, Error-based, Union, Stacked querys, Time-based, Inline queries
                --flush-session
                - Si el SQLi es Blind Boolean Based , se especifica con una "B"
                - Si el SQLi es Error Based/Double Query , se especifica con una "E"
                - Si el SQLi es Union Based , se especifica con una "U"
                - Si el SQLi es Stacked querys , se especifica con una "S"
                - Si el SQLi es Time Based , se especifica con una "T"
                - Si el SQLi es Inline queries , se especifica con una "Q"
                --forms si queremos que busque automáticamente los campos de formularios
                --proxy= usar servidor proxy 
                --sql-query añadir consulta sql
                --tamper= scripts ofuscación y bypass (ejemplo space2mysqlblank.py, charencode.py, base64encode.py, randomcomments.py, etc)
                --chek-tor ---> User Tor Anonymity Network
                --tor-port ---> Set Tor proxy port other than default
                --tor-type ---> Set Tor proxy type (HTTP (default ), SOCKS4 or SOCKS5)
                Listado completo  en la documentación oficial:
                 
                 https://github.com/sqlmapproject/sqlmap/wiki/Usage
                 
                 ''')
    print('sqlmap')

@bot.message_handler(commands=['nuclei'])  
def nuclei(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a continuación te dejo algo de info que espero te ayude: \n'.format(user_name) + nuclei)
    print('nuclei')
nuclei = '''
Nuclei es un escáner de vulnerabilidades escrito en Go permitiendo realizar la detección en diferentes protocolos, como por ejemplo; TCP, HTTP, DNS.

La primera vez que se ejecuta la herramienta, lo primero que hace es descargar las plantillas desarrolladas por la comunidad y almacenar dichos ficheros en $HOME/nuclei-templates. A partir de este punto, se puede lanzar la herramienta utilizando cualquiera de las plantillas ya existentes o con una nueva.


Hay varias opciones que son interesantes a la hora de ejecutar la herramienta y simplemente leyendo la ayuda se pueden entender fácilmente, sin embargo las más importantes son las siguientes:

-target / -u: Permite indicar una URL sobre la que se van a realizar las pruebas.
-list / -l: Permite indicar un listado de objetivos en un fichero de texto, una URL por cada línea en el fichero.
-automatic-scan / -as: Ejecuta un escaneo automático utilizando Wappalyzer para la detección de la arquitectura del objetivo.
-templates / -t: Listado de plantillas o de directorios que contienen plantillas separado por comas.
-tl: Simplemente lista todas las plantillas que detecta nuclei. Si se ejecuta la herramienta sin la opción «-templates» enseñará las plantillas de la comunidad que como se ha indicado antes, se encuentran en el directorio $HOME/nuclei-templates.
-validate: Valida las plantillas que se han enviado con la opción «-templates» para comprobar que los ficheros YAML se encuentran bien formados.
-et / -exclude-templates: Listado de plantillas o de directorios que contienen plantillas que debe ser ignorado por nuclei separado por comas.
-s / –severity: Indica que las plantillas deben ser ejecutadas en función del campo «severity» de la plantilla, en donde los posibles valores pueden ser: info, low, medium, high, critical, unknown
-o / -output: Fichero de salida en donde se almacenan los problemas/vulnerabilidades descubiertos por la herramienta.
-sresp / -store-resp: Almacena todas las peticiones y respuestas que ha gestionado nuclei en el directorio indicado con la opción «-output».
-silent: No enseña trazas, solamente los problemas descubiertos.
-config: Permite indicar un fichero de configuración personalizado para modificar el comportamiento por defecto de la herramienta.
-update: Actualizar la herramienta
-up / -update-templates: Actualizar las plantillas de la comunidad a la versión más reciente.
-duc / -disable-update-check: Por defecto Nuclei verifica si las plantillas locales se encuentran actualizadas, con esta opción se deshabilita este comportamiento.
'''

@bot.message_handler(commands=['metasploit'])  
def metasploit(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a continuación te dejo algo de info sobre Metasploit: \n'.format(user_name) + info)
    print('metasploit')
info = '''
       Metasploit consta de varias herramientas distintas:

       msfconsole. Consola de Metasploit.
       msfcli. Nos permite ejecutar módulos directamente sin entrar en la consola.
       msfpayload. Para generar payloads.
       msfencode. Permite codificar los payloads para quitar null bytes por ejemplo.
       msfvenom. Combinación de msfpayload y msfencode en una sola herramienta.

       Los pasos básicos a seguir para explotar vulnerabilidades usando Metasploit son:


       Elegir y configurar el exploit (como hemos dicho, código que permite explotar la vulnerabilidad de un sistema). 
       Confirmar si el objetivo es susceptible al exploit elegido (este paso es opcional). 
       Elegir y configurar el payload (código que se ejecuta una vez explotemos la vulnerabilidad). 
       Elegir la técnica de encode o codificación para que el payload no sea detectados por los elementos de seguridad del equipo (también es opcional aunque recomendable). 
       Ejecutar el exploit. 
       Para la realización de éstas y otras acciones, metasploit incorpora las siguientes herramientas:
       
       
       msfconsole: línea de comandos de Metasploit. 
       msfcli: interfaz que permite lanzar un módulo concreto mediante su configuración en la misma ejecución de la aplicación. 
       msfgui: interfaz gráfica de Metasploit. 
       msfd: servicio que queda a la escucha de recibir conexiones para ofrecer una línea de comandos en remoto. 
       msfbinscan: permite realizar búsquedas en ejecutables de instrucciones de salto, instrucciones POP,... 
       msfpescan: permite realizar un análisis sobre DLLs y obtener la dirección de retorno deseada para que la shellcode se ejecute. 
       msfpayload: permite generar payloads en distintos lenguajes de programación, pudiendo embeberlos en ejecutables Windows o binarios de UNIX. 
       msfencode: permite ofuscar el código del payload para evitar su detección. 
       msfvenom: es la unión de msfpayload y msfencode. 
       msfupdate: se utiliza para actualizar el framework. 
       
       
       Además de estas herramientas, metasploit se compone de distintos módulos. Estos módulos son:
       
       
       Módulo auxiliary: permite la interacción de herramientas externas, como pueden ser escaners de vulnerabilidades, sniffers,... 
       Módulo encoders: nos proporciona los diferentes algoritmos para codificar y ofuscar los payloads. 
       Módulo exploits: aquí se encuentran todos los exploits disponibles en el framework. 
       Módulo payloads: multitud de códigos que se ejecutan una vez tenga éxito el exploit. 
       Módulo post: funcionalidades para la fase de post explotación durante un pentesting. 
       Módulo nops: permite realizar u obtener operaciones nop. 

'''

@bot.message_handler(commands=['crackmapexec'])  
def cme(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, a continuación te dejo algo de info sobre CME: \n'.format(user_name) + cme)
    print('crackmapexec')
cme = '''
CrackMapExec o CME es una herramienta diseñada para la post-explotación, su principal característica es que permite hacer movimientos laterales dentro una red local. Pero también tiene muchas opciones de uso, ya que usa módulos y funcionalidades externas.

Esta escrita en Python y puedes descargarse desde su Github.

CME hace uso de 5 protocolos que son: smb, winrm, ssh, http o mssql. Cada uno de estos protocolos tiene diferentes módulos de uso, para ver estos módulos se ejecuta cme con el siguiente parametro:

./cme (protocolo) -L

El protocolo SMB suele ser el más usado ya que la herramienta se desarrolló pensando en entornos Windows y por esto es el que mas módulos tiene, este además se usa para poder hacer movimientos laterales, para ello necesitas unas credenciales o un hash NTLM.

Por ejemplo, dispones de unas credenciales para el usuario administrador (qué suerte!), con CME puedes sacar la lista de usuarios de una máquina Windows con la siguiente instrucción:

./cme smb 192.168.xx.xx -u administrador -p 123456789 --users

También se pueden hacer búsquedas por ficheros dentro del sistema con los parámetros – -pattern y – -spider, por ejemplo si queremos buscar ficheros log dentro del sistema, lo haremos con la siguiente instrucción:

./cme smb 192.168.xx.xx -u administrador -p 123456789 --spider c\$ --pattern log

Otra característica de CME, es que tiene la posibilidad de hacer una consulta a las políticas de contraseña de la máquina que estamos testeando con el parámetro \'--pass-pol\', la instrucción sería:
./cme smb 192.168.xx.xx -u administrador -p 123456789 --pass-pol

Y no podía faltar una descarga de todas las credenciales de la máquina, ya que CrackMapExec es una herramienta para el movimiento lateral, necesitaremos estas credenciales para poder movernos por la red. Podemos usar los modificadores para descargar la SAM, LSA  o NTDS, por ejemplo para descargar la sam:

./cme smb 192.168.xx.xx -u administrador -p 123456789 --sam

Si tenemos un hash NTLM, podremos usarlo para autenticarnos con el modificador -H de esta forma:

./cme smb 192.168.xx.xx -u administrador -H aqui el hash NTLM

También se pueden ejecutar comandos con diferentes técnicas usando el parámetro -x, por ejemplo podemos ejecutar un «whoami» de la siguiente forma:

./cme smb 192.168.xx.xx -u administrador -p 123456789 -x whoami

Con la ejecución de comandos se abren un montón de posibilidades para meter otras herramientas en escena como pueden ser Empire o Meterpreter.
CrackMapExec es una herramienta muy buena para tareas de pentesting en entornos Microsoft, estos son unos ejemplos básicos de uso, pero la herramienta dispone de un montón de opciones para ayudar al Pentester.
'''
    

@bot.message_handler(commands=['bettercap'])  
def better(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, aquí tienes algo de info sobre la herramienta Bettercap o navaja suiza del tráfico de red: \n'.format(user_name) + better)
    print('bettercap')
better = '''
        Bettercap es una herramienta muy potente que es compatible con las principales distribuciones basadas en Linux, algunas de sus principales características son las siguientes:
        
        Escáner de redes WiFi, permite hacer ataques de desautenticación, también permite realizar ataques sin clientes a asociaciones PMKID, permite capturar handshakes de clientes que usan protocolo WPA y WPA2.
        Escáner de dispositivos BLE (Bluetooth Low Energía) para leer y escribir información.
        Escáner de dispositivos inalámbricos que usen la banda de 2.4GHz, como los ratones inalámbricos, también permite realizar ataques MouseJacking con inyección de datos.
        Permite hacer ataques pasivos y activos a redes IP
        Permite realizar ataques MitM basados en ARP, DNS y también DHCPv6, con el objetivo de capturar toda la información.
        Permite crear un proxy HTTP/HTTPS para levantar el tráfico seguro HTTPS, y facilita enormemente el uso de scripts.
        Sniffer de red muy potente para recolección de credenciales de usuario.
        Escáner de puertos muy rápido
        Tiene una potente API REST para realizar ataques fácilmente.
        Incorpora una interfaz gráfica de usuario para facilitar los ataques, aunque el terminal de comandos es muy potente.
        Tenemos una gran cantidad de módulos de diferentes categorías para ampliar funcionalidades
        
        El sniffer incorporado es actualmente capaz de diseccionar e imprimir desde la red (o desde un archivo PCAP previamente capturado) las siguientes informaciones:
        URLs visitadas
        Hosts HTTPS que están siendo visitados
        HTTP POSTed datos
        Autenticaciones HTTP Basic y Digest
        Cookies HTTP.
        Credenciales de FTP
        Credenciales de IRC
        Credenciales POP, IMAP y SMTP
        Credenciales NTLMv1 / v2 (HTTP, SMB, LDAP, etc)
        Credenciales del protocolo DICT
        Credenciales del MPD
        Credenciales NNTP
        Mensajes DHCP y autenticación
        Credenciales de inicio de sesión de REDIS
        Credenciales RLOGIN
        Credenciales SNPP
        
        La instalación bajo kali es muy simple y bettercap también es compatible con X os, Android, Windows. 
        
        Módulos:
         
        api.rest: módulo API RESTful
        arp.spoof: módulo de falsificación de arp
        ble.recon: módulo de descubrimiento de dispositivos Bluetooth de baja energía
        net.sniff: módulo de rastreo de red
        dhcp6.spoof: módulo de falsificación de dhcp6 (manipula el servidor DNS del cliente falsificando paquetes DHCP, por lo que debe habilitarse junto con dns.spoof)
        dns.spoof: módulo de suplantación de DNS
        events.stream: módulo de salida de flujo (es decir, la salida del programa se muestra constantemente en la interfaz del terminal, como la información interceptada por arp)
        wifi: módulo wifi, con ataque automático (wifi killer)
'''


@bot.message_handler(commands=['help'])
def send_help(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, "Hola {}, puedes probar con uno de estos comandos:\n /pentest - llama al bot\n /nmap - Listado de comandos de Nmap\n /reverse - Link y pdf para soporte con Reverse Shells\n /puertos - pdf con tabla de puertos comunes\n Info sobre otras herramientas:👇🏻\n /metasploit\n /sqlmap\n /nuclei\n /bettercap\n /crackmapexec".format(user_name))
    print('help')

user = telebot.TeleBot.get_me
print(user)
print('\n')
update = telebot.TeleBot.get_updates
print(update)

bot.polling()
